Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук
Кафедра програмної інженерії






ЗВІТ
до практичного завдання № 2
з дисципліни «Аналіз та рефакторинґ коду»
на тему: «Методи рефакторинґу: Replace Magic Number with Symbolic Constant, Consolidate Conditional Expression, Separate Query from Modifier на прикладі мови програмування C#.»




Виконала
ст. гр. ПЗПІ-23-10
Бєлікова Марина




Перевірив
ст. викладач катедри ПІ
Сокорчук Ігор Петрович








Харків 2025
1 ІСТОРІЯ ЗМІН
№
	Дата
	Версія звіту
	Опис змін та виправлень
	1
	12.11.2025
	0.1
	Створено розділ «Завдання»
	2
	12.11.2025
	0.1
	Створено розділ «Опис Виконаної роботи»
	3
	12.11.2025
	0.1
	Створено розділ «Висновки»
	4
	12.11.2025
	0.1
	Створено розділ «Використані джерела» 
	5
	12.11.2025
	0.1
	Створено розділ «Додаток А»
	6
	12.11.2025
	0.1
	Створено розділ «Додаток Б»
	7
	12.11.2025
	0.1
	Створено розділ «Додаток В»
	


________________
2 ЗАВДАННЯ
Завдання полягає у вивченні та практичному застосуванні методів рефакторинґу Replace Magic Number with Symbolic Constant, Consolidate Conditional Expression, Separate Query from Modifier на прикладі мови програмування C#. 
У процесі виконання роботи потрібно дослідити теоретичні основи цих методів, з’ясувати їх призначення, переваги та типові ситуації використання. Далі необхідно реалізувати приклади програмного коду до і після застосування кожного з методів, щоб продемонструвати, як саме відбувається покращення структури коду без зміни його функціональності. Особливу увагу слід приділити поясненню того, чому було доцільно використати певний метод у конкретному випадку, а також які переваги це дало з точки зору підтримуваності, зрозумілості та повторного використання коду.













________________


3 ОПИС ВИКОНАНОЇ РОБОТИ
3.1 Вступ
Моя доповідь присвячена темі рефакторингу програмного коду, що є важливою складовою професійної розробки програмного забезпечення. Рефакторинг — це зміна внутрішньої структури програмного коду без зміни його зовнішньої поведінки. Його мета — покращити читабельність, зменшити складність, спростити підтримку та зробити код більш гнучким для майбутніх змін.
Для ілюстрації я використала приклади на мові програмування C#.  Кожен метод буде розглянутий із конкретними прикладами коду «до» і «після» рефакторингу, а також із поясненням переваг внесених змін.
Я розглянула 3 методи:
Replace Magic Number with Symbolic Constant, 
Consolidate Conditional Expression, 
Separate Query from Modifier
3.2 Три методи рефакторинґу
Replace Magic Number with Symbolic Constant (136). Цей метод полягає у заміні незрозумілого числового літерала, вбудованого в код ("магічного числа"), на іменовану константу (const або static readonly). Мета — зробити код самодокументованим.
Як зазначає Мартін Фаулер, правильне іменування констант пояснює призначення числа, усуває двозначність та створює єдину точку істини для цього значення, що є критично важливим для підтримки коду.
Consolidate Conditional Expression (158). Метод застосовується, коли кілька незалежних умов призводять до однакового результату (наприклад, виконують ідентичну дію або повертають однакове значення). Рефакторинг полягає в об'єднанні цих умов в один вираз за допомогою логічних операторів (|| або &&).
Цей підхід допомагає усунути дублювання тіла if-блоку, спрощує логіку та робить намір коду щодо групування умов абсолютно чітким.ж результату або виконують ідентичну дію.
Separate Query from Modifier (182). Цей метод реалізує принцип Command-Query Separation (CQS), вимагаючи, щоб метод або повертав дані (Query), або змінював стан об'єкта (Modifier/Command), але не робив обидва дії одночасно.
Фаулер підкреслює, що такий підхід значно покращує надійність та тестованість коду, оскільки викликаючи метод-запит, розробник упевнений, що не отримає несподіваних побічних ефектів.
3.3 Replace Magic Number with Symbolic Constant
Цей метод спрямований на усунення числових літералів, вбудованих безпосередньо в логіку коду, значення яких незрозуміле з контексту ("магічні числа").
Проблема: Такі числа ускладнюють читання, оскільки не пояснюють, що вони означають (наприклад, чому саме 40 чи 1.5). Вони створюють ризик помилок, оскільки при зміні бізнес-правила (наприклад, зміна ставки) доводиться вручну шукати і оновлювати число в багатьох місцях.
Рішення: Заміна числа на іменовану константу (const або static readonly) з описовою назвою (наприклад, STANDARD_WORK_WEEK).
Результат: Код стає самодокументованим та легко змінюваним, оскільки всі його використання посилаються на єдину точку істини.
3.4 Consolidate Conditional Expression
Цей метод застосовується, коли кілька різних перевірок призводять до одного і того ж результату або виконують ідентичну дію.
Проблема: Код містить дублювання блоків if, кожен з яких виконує одну й ту саму операцію (наприклад, повертає true або викликає метод). Це робить метод надмірно довгим, ускладнює читання логіки та підвищує ризик помилок, якщо однакова дія не буде оновлена в усіх блоках одночасно.
Рішення: Об'єднання всіх окремих умов в один складний вираз за допомогою логічного оператора || (АБО).
Результат: Усунення дублювання, значне спрощення логіки та підвищення її наочності. Читач одразу бачить, що виконання будь-якої з перевірок призводить до бажаного результату.
3.5 Separate Query from Modifier 
Цей метод реалізує принцип Command-Query Separation (CQS), розділяючи функції запиту та модифікації стану об'єкта.
Проблема: Існування методу, який одночасно повертає значення (наприклад, чи є товар в наявності) і змінює стан об'єкта (наприклад, зменшує запас). Такий "гібридний" метод ускладнює розуміння його намірів та унеможливлює простий запит стану без непередбачуваних побічних ефектів.
Рішення: Розділення логіки на два методи:
1. Запит (Query): Повертає значення (наприклад, CanShip()) і не змінює стан.
2. Модифікатор (Modifier): Змінює стан (наприклад, ShipProduct()) і повертає void або використовується після перевірки запитом.
Результат: Кардинальне покращення Тестованості (Query-метод не має побічних ефектів, що ідеально для юніт-тестів) та Надійності коду.


4 ВИСНОВКИ
Обрані методи рефакторингу (136, 158, 182) демонструють три основні напрямки покращення якості коду:
Читабельність та Самодокументування: Завдяки Replace Magic Number... та Consolidate Conditional Expression код стає зрозумілим з першого погляду, зменшуючи потребу в коментарях та когнітивне навантаження на розробника. Тестованість та Надійність: Separate Query from Modifier дозволяє створювати "чисті" тестовані функції, які значно спрощують відлагодження та верифікацію логіки. Підтримка та Розширюваність: Усунення дублювання та централізація значень у константах робить систему більш гнучкою та стійкою до змін у бізнес-логіці.
Replace Magic Number with Symbolic Constant (136): Підвищує Читабельність та Підтримку коду, перетворюючи незрозумілі числа на самодокументовані константи. Це створює єдину точку контролю для ключових значень, мінімізуючи ризик помилок при змінах.
Consolidate Conditional Expression (158): Спрощує Логіку та усуває Дублювання Коду, об'єднуючи декілька умов, які ведуть до одного результату. Це робить метод компактнішим і менш схильним до помилок.
Separate Query from Modifier (182): Забезпечує Надійність та Тестованість, впроваджуючи принцип CQS (Command-Query Separation). Розділення функцій запиту (Query) і модифікації (Modifier) робить наміри кожного методу чіткими та дозволяє ізольовано тестувати логіку перевірки.
Загальний Вплив: Регулярне застосування цих простих рефакторингів робить код чистішим, гнучкішим та безпечнішим для подальшого розвитку.
Рефакторинг — це не разове завдання, а щоденна дисципліна, яка забезпечує здоров'я та довговічність будь-якого проєкту.




5 ВИКОРИСТАНІ ДЖЕРЕЛА
1. Martin Fowler's Refactoring Catalog— Режим доступу:
https://refactoring.com/catalog/
Дата звернення: 10.11.25
2. Martin Fowler Refactoring: Improving the Design of Existing Code 1999. 464с
3. Robert C. Martin (Uncle Bob) Clean Code: A Handbook of Agile Software Craftsmanship 2008. 464с















________________
ДОДАТОК А
Відеозапис
Відеозапис доповіді: https://www.youtube.com/watch?v=KolbuXxB3wU

           Хронологічний опис відеозапису:
0:00 - Вступ 
0:21 - Три методи рефакторинґу
0:46 - Replace Magic Number with Symbolic Constant
1:08 - Replace Magic Number with Symbolic Constant до рефакторинґу
1:56 - Replace Magic Number with Symbolic Constant після рефакторинґу
2:24 - Consolidate Conditional Expression
2:42 - Consolidate Conditional Expression до рефакторинґу
3:31 - Consolidate Conditional Expression після рефакторинґу
3:59 - Separate Query from Modifier 
4:16 - Separate Query from Modifier  до рефакторинґу
5:12 - Separate Query from Modifier  після рефакторинґу
6:03 - Висновки
7:01 - Список використаних джерел








ДОДАТОК Б
Слайди презентації
  
Рисунок Б.1 — Методи рефакторінгу коду
  
Рисунок Б.2 — Вступ
  
Рисунок Б.3 — Три методи
  Рисунок Б.4 — Replace Magic Number with Symbolic Constant


  


Рисунок Б.5 — Replace Magic Number with Symbolic Constant до рефакторінгу
  


Рисунок Б.6 — Replace Magic Number with Symbolic Constant після рефакторінгу
  
Рисунок Б.7 — Consolidate Conditional Expression 
  


Рисунок Б.8 —Consolidate Conditional Expression до рефакторінгу
  
Рисунок Б.9 — Consolidate Conditional Expression до рефакторінгу


  
Рисунок Б.10 — Separate Query from Modifier 


  
Рисунок Б.11 — Separate Query from Modifier до рефакторінгу


  

Рисунок Б.12 — Separate Query from Modifier після рефакторінгу


  

Рисунок Б.13 — Висновки
  

Рисунок Б.14 — Використані джерела




ДОДАТОК В
Програмний код
В.1 Приклад програмного коду до рефакторинґу
GitHub репозиторій:
https://github.com/NureBielikovaMaryna/ark-pzpi-23-10-bielikova-maryna/blob/main/Pract2%20/ark-pzpi-23-10-Bielikova-Maryna-pract2%20/code-examples-refactoring-methods.cs
1 public class Employee
2 {
3     // Код До: 40 і 1.5 - це "магічні числа"
4     public double CalculateOvertime(int hoursWorked)
5     {
6         if (hoursWorked > 40)
7         {
8             return (hoursWorked - 40) * 1.5; 
9         }
10        return 0;
11    }
12 }


В.2 Приклад програмного коду після рефакторинґу
GitHub репозиторій: https://github.com/NureBielikovaMaryna/ark-pzpi-23-10-bielikova-maryna/blob/main/Pract2%20/ark-pzpi-23-10-Bielikova-Maryna-pract2%20/code-examples-refactoring-methods.cs 
1 // --- Після Рефакторингу ---
2 public class Employee
3 {
4     // Виносимо значення в константи для C#
5     private const int STANDARD_WORK_WEEK = 40;
6     private const double OVERTIME_RATE = 1.5;
7
8     public double CalculateOvertime(int hoursWorked)
9     {
10        if (hoursWorked > STANDARD_WORK_WEEK)
11        {
12           return (hoursWorked - STANDARD_WORK_WEEK) * OVERTIME_RATE; 
13        }
14        return 0;
15    }
16 }














В.3 Приклад програмного коду до рефакторинґу
GitHub репозиторій: https://github.com/NureBielikovaMaryna/ark-pzpi-23-10-bielikova-maryna/blob/main/Pract2%20/ark-pzpi-23-10-Bielikova-Maryna-pract2%20/code-examples-refactoring-methods.cs 
1 public bool IsSpecialClearance(User user)
2 {
3     // Код До: Дублювання return true;
4     if (user.IsAdmin)
5     {
6         return true; 
7     }
8     if (user.Department == "Security")
9     {
10        return true; 
11    }
12    if (user.YearsOfService > 20)
13    {
14        return true; 
15    }
16    return false;
17 }


В.4 Приклад програмного коду після рефакторинґу
GitHub репозиторій: https://github.com/NureBielikovaMaryna/ark-pzpi-23-10-bielikova-maryna/blob/main/Pract2%20/ark-pzpi-23-10-Bielikova-Maryna-pract2%20/code-examples-refactoring-methods.cs 
1 // --- Після Рефакторингу ---
2 public bool IsSpecialClearance(User user)
3 {
4      // Об'єднання умов оператором || (АБО)
5     if (user.IsAdmin || 
6         user.Department == "Security" || 
7         user.YearsOfService > 20)
8     {
9         return true; 
10    }
11    return false;
12 }


В.5 Приклад програмного коду до рефакторинґу
GitHub репозиторій:
https://github.com/NureBielikovaMaryna/ark-pzpi-23-10-bielikova-maryna/blob/main/Pract2%20/ark-pzpi-23-10-Bielikova-Maryna-pract2%20/code-examples-refactoring-methods.cs 
1 public class InventoryManager
2 {
3     private int stock = 10;
4
5     // Метод одночасно повертає значення (чи можна відвантажити) ТА зменшує запас (модифікатор)
6      public bool TryShipProduct(int quantity)
7     {
8        if (stock >= quantity)
9         {
10            stock -= quantity; // Зміна стану
11            Console.WriteLine($"Shipped {quantity} items.");
12            return true; // Повернення результату
13        }
14        return false;
15    }
16 }


В.6 Приклад програмного коду після рефакторинґу
GitHub репозиторій: 
https://github.com/NureBielikovaMaryna/ark-pzpi-23-10-bielikova-maryna/blob/main/Pract2%20/ark-pzpi-23-10-Bielikova-Maryna-pract2%20/code-examples-refactoring-methods.cs 
1 // --- Після Рефакторингу ---
2 public class InventoryManager
3 {
4     private int stock = 10;
5
6     // 1. Метод-Запит (Query): Тільки повертає значення, НЕ змінює стан
7     public bool CanShip(int quantity)
8     {
9         return stock >= quantity;
10    }
11
12    // 2. Метод-Модифікатор (Modifier): Тільки змінює стан (void), викликається після перевірки
13     public void ShipProduct(int quantity)
14    {
15        if (CanShip(quantity))
16        {
17            stock -= quantity; // Зміна стану
18            Console.WriteLine($"Shipped {quantity} items.");
19        }
20        else
21        {
22            throw new InvalidOperationException("Not enough stock.");
23        }
24    }
25 }
